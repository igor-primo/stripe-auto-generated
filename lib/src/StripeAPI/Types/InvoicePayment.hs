{-# LANGUAGE MultiWayIf #-}
-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.
{-# LANGUAGE OverloadedStrings #-}

-- | Contains the types generated from the schema InvoicePayment
module StripeAPI.Types.InvoicePayment where

import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text as Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified StripeAPI.Common
import StripeAPI.TypeAlias
import {-# SOURCE #-} StripeAPI.Types.DeletedInvoice
import {-# SOURCE #-} StripeAPI.Types.Invoice
import {-# SOURCE #-} StripeAPI.Types.InvoicesPaymentsInvoicePaymentAssociatedPayment
import {-# SOURCE #-} StripeAPI.Types.InvoicesPaymentsInvoicePaymentStatusTransitions
import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe

-- | Defines the object schema located at @components.schemas.invoice_payment@ in the specification.
--
-- Invoice Payments represent payments made against invoices. Invoice Payments can
-- be accessed in two ways:
-- 1. By expanding the \`payments\` field on the [Invoice](https:\/\/stripe.com\/docs\/api\#invoice) resource.
-- 2. By using the Invoice Payment retrieve and list endpoints.
--
-- Invoice Payments include the mapping between payment objects, such as Payment Intent, and Invoices.
-- This resource and its endpoints allows you to easily track if a payment is associated with a specific invoice and
-- monitor the allocation details of the payments.
data InvoicePayment = InvoicePayment
  { -- | amount_paid: Amount that was actually paid for this invoice, in cents (or local equivalent). This field is null until the payment is \`paid\`. This amount can be less than the \`amount_requested\` if the PaymentIntent’s \`amount_received\` is not sufficient to pay all of the invoices that it is attached to.
    invoicePaymentAmountPaid :: (GHC.Maybe.Maybe (StripeAPI.Common.Nullable GHC.Types.Int)),
    -- | amount_requested: Amount intended to be paid toward this invoice, in cents (or local equivalent)
    invoicePaymentAmountRequested :: GHC.Types.Int,
    -- | created: Time at which the object was created. Measured in seconds since the Unix epoch.
    invoicePaymentCreated :: GHC.Types.Int,
    -- | currency: Three-letter [ISO currency code](https:\/\/www.iso.org\/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https:\/\/stripe.com\/docs\/currencies).
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    invoicePaymentCurrency :: Data.Text.Internal.Text,
    -- | id: Unique identifier for the object.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    invoicePaymentId :: Data.Text.Internal.Text,
    -- | invoice: The invoice that was paid.
    invoicePaymentInvoice :: InvoicePaymentInvoice'Variants,
    -- | is_default: Stripe automatically creates a default InvoicePayment when the invoice is finalized, and keeps it synchronized with the invoice’s \`amount_remaining\`. The PaymentIntent associated with the default payment can’t be edited or canceled directly.
    invoicePaymentIsDefault :: GHC.Types.Bool,
    -- | livemode: Has the value \`true\` if the object exists in live mode or the value \`false\` if the object exists in test mode.
    invoicePaymentLivemode :: GHC.Types.Bool,
    -- | payment:
    invoicePaymentPayment :: InvoicesPaymentsInvoicePaymentAssociatedPayment,
    -- | status: The status of the payment, one of \`open\`, \`paid\`, or \`canceled\`.
    --
    -- Constraints:
    --
    -- * Maximum length of 5000
    invoicePaymentStatus :: Data.Text.Internal.Text,
    -- | status_transitions:
    invoicePaymentStatusTransitions :: InvoicesPaymentsInvoicePaymentStatusTransitions
  }
  deriving
    ( GHC.Show.Show,
      GHC.Classes.Eq
    )

instance Data.Aeson.Types.ToJSON.ToJSON InvoicePayment where
  toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_paid" Data.Aeson.Types.ToJSON..=)) (invoicePaymentAmountPaid obj) : ["amount_requested" Data.Aeson.Types.ToJSON..= invoicePaymentAmountRequested obj] : ["created" Data.Aeson.Types.ToJSON..= invoicePaymentCreated obj] : ["currency" Data.Aeson.Types.ToJSON..= invoicePaymentCurrency obj] : ["id" Data.Aeson.Types.ToJSON..= invoicePaymentId obj] : ["invoice" Data.Aeson.Types.ToJSON..= invoicePaymentInvoice obj] : ["is_default" Data.Aeson.Types.ToJSON..= invoicePaymentIsDefault obj] : ["livemode" Data.Aeson.Types.ToJSON..= invoicePaymentLivemode obj] : ["payment" Data.Aeson.Types.ToJSON..= invoicePaymentPayment obj] : ["status" Data.Aeson.Types.ToJSON..= invoicePaymentStatus obj] : ["status_transitions" Data.Aeson.Types.ToJSON..= invoicePaymentStatusTransitions obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invoice_payment"] : GHC.Base.mempty))
  toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount_paid" Data.Aeson.Types.ToJSON..=)) (invoicePaymentAmountPaid obj) : ["amount_requested" Data.Aeson.Types.ToJSON..= invoicePaymentAmountRequested obj] : ["created" Data.Aeson.Types.ToJSON..= invoicePaymentCreated obj] : ["currency" Data.Aeson.Types.ToJSON..= invoicePaymentCurrency obj] : ["id" Data.Aeson.Types.ToJSON..= invoicePaymentId obj] : ["invoice" Data.Aeson.Types.ToJSON..= invoicePaymentInvoice obj] : ["is_default" Data.Aeson.Types.ToJSON..= invoicePaymentIsDefault obj] : ["livemode" Data.Aeson.Types.ToJSON..= invoicePaymentLivemode obj] : ["payment" Data.Aeson.Types.ToJSON..= invoicePaymentPayment obj] : ["status" Data.Aeson.Types.ToJSON..= invoicePaymentStatus obj] : ["status_transitions" Data.Aeson.Types.ToJSON..= invoicePaymentStatusTransitions obj] : ["object" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invoice_payment"] : GHC.Base.mempty)))

instance Data.Aeson.Types.FromJSON.FromJSON InvoicePayment where
  parseJSON = Data.Aeson.Types.FromJSON.withObject "InvoicePayment" (\obj -> ((((((((((GHC.Base.pure InvoicePayment GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount_paid")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount_requested")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invoice")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "is_default")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "livemode")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payment")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status_transitions"))

-- | Create a new 'InvoicePayment' with all required fields.
mkInvoicePayment ::
  -- | 'invoicePaymentAmountRequested'
  GHC.Types.Int ->
  -- | 'invoicePaymentCreated'
  GHC.Types.Int ->
  -- | 'invoicePaymentCurrency'
  Data.Text.Internal.Text ->
  -- | 'invoicePaymentId'
  Data.Text.Internal.Text ->
  -- | 'invoicePaymentInvoice'
  InvoicePaymentInvoice'Variants ->
  -- | 'invoicePaymentIsDefault'
  GHC.Types.Bool ->
  -- | 'invoicePaymentLivemode'
  GHC.Types.Bool ->
  -- | 'invoicePaymentPayment'
  InvoicesPaymentsInvoicePaymentAssociatedPayment ->
  -- | 'invoicePaymentStatus'
  Data.Text.Internal.Text ->
  -- | 'invoicePaymentStatusTransitions'
  InvoicesPaymentsInvoicePaymentStatusTransitions ->
  InvoicePayment
mkInvoicePayment invoicePaymentAmountRequested invoicePaymentCreated invoicePaymentCurrency invoicePaymentId invoicePaymentInvoice invoicePaymentIsDefault invoicePaymentLivemode invoicePaymentPayment invoicePaymentStatus invoicePaymentStatusTransitions =
  InvoicePayment
    { invoicePaymentAmountPaid = GHC.Maybe.Nothing,
      invoicePaymentAmountRequested = invoicePaymentAmountRequested,
      invoicePaymentCreated = invoicePaymentCreated,
      invoicePaymentCurrency = invoicePaymentCurrency,
      invoicePaymentId = invoicePaymentId,
      invoicePaymentInvoice = invoicePaymentInvoice,
      invoicePaymentIsDefault = invoicePaymentIsDefault,
      invoicePaymentLivemode = invoicePaymentLivemode,
      invoicePaymentPayment = invoicePaymentPayment,
      invoicePaymentStatus = invoicePaymentStatus,
      invoicePaymentStatusTransitions = invoicePaymentStatusTransitions
    }

-- | Defines the oneOf schema located at @components.schemas.invoice_payment.properties.invoice.anyOf@ in the specification.
--
-- The invoice that was paid.
data InvoicePaymentInvoice'Variants
  = InvoicePaymentInvoice'Text Data.Text.Internal.Text
  | InvoicePaymentInvoice'Invoice Invoice
  | InvoicePaymentInvoice'DeletedInvoice DeletedInvoice
  deriving (GHC.Show.Show, GHC.Classes.Eq)

instance Data.Aeson.Types.ToJSON.ToJSON InvoicePaymentInvoice'Variants where
  toJSON (InvoicePaymentInvoice'Text a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (InvoicePaymentInvoice'Invoice a) = Data.Aeson.Types.ToJSON.toJSON a
  toJSON (InvoicePaymentInvoice'DeletedInvoice a) = Data.Aeson.Types.ToJSON.toJSON a

instance Data.Aeson.Types.FromJSON.FromJSON InvoicePaymentInvoice'Variants where
  parseJSON val = case (InvoicePaymentInvoice'Text Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((InvoicePaymentInvoice'Invoice Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((InvoicePaymentInvoice'DeletedInvoice Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
    Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
    Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
